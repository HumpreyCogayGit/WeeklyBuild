<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Canvas Color Effects</title>
</head>
<body>
  <h2>Image Toggle & Color Effects</h2>
  <button onclick="toggleCanvas()">Toggle View</button>
  <input type="file" id="imageUpload" accept="image/*" style="margin-left:10px;" />
  <select id="effectSelector" onchange="applyEffect()" style="margin-left:10px;">
    <option value="0">Custom Effect</option>
    <option value="1">Invert Colors</option>
    <option value="2">Grayscale</option>
    <option value="3">Sepia</option>
    <option value="4">High Contrast</option>
  </select>
  <br>
  <canvas id="CanvasOR" width="700" height="500"></canvas>
  <canvas id="CanvasBW" width="700" height="500" style="display:none;"></canvas>
  
    <div id="writeup" style="max-width:900px; padding:20px; text-align:justify;">
      <h2>Overview</h2>
      <p>
        Basic Pixel Coloration is an interactive web demo that lets you upload any image and instantly apply a variety of color effects using the HTML5 Canvas API. Choose from custom coloration, invert, grayscale, sepia, and high contrast effects, and see the results in real time. The app automatically resizes to fit your image, so you can experiment with photos of any size.
      </p>

      <h3>Concept and Algorithm</h3>
      <p>
        The program loads your image and draws it onto a canvas. When you select an effect, the pixel data is read and transformed using color mapping arrays or formulas, then written back to the canvas for instant feedback. You can toggle between the original and processed views, and upload new images at any time.
      </p>

      <h4>How It Works</h4>
      <ol>
        <li>Upload an image or use the default.</li>
        <li>Canvas resizes to fit the image.</li>
        <li>Select a color effect from the dropdown.</li>
        <li>Pixel data is processed and displayed live.</li>
        <li>Toggle between original and processed views.</li>
      </ol>

      <h3>Key Features</h3>
      <ul>
        <li>Upload any image (JPG, PNG, etc.)</li>
        <li>Instant color effect application: invert, grayscale, sepia, high contrast, custom</li>
        <li>Canvas resizes to fit your image</li>
        <li>Toggle between original and processed views</li>
        <li>Efficient pixel manipulation with Canvas ImageData</li>
      </ul>

      <h3>Algorithm Summary</h3>
      <ul>
        <li><b>Custom Effect:</b> Applies non-linear color mapping to each channel using pre-defined arrays (RColorRange, GColorRange, BColorRange), creating a unique stylized coloration.</li>
        <li><b>Invert Colors:</b> For each pixel, replaces R, G, B values with 255 minus their original value, producing a photographic negative effect.</li>
        <li><b>Grayscale:</b> Calculates the average of R, G, B for each pixel and sets all three channels to this value, resulting in a monochrome image.</li>
        <li><b>Sepia:</b> Uses weighted sums of the original R, G, B values to simulate a warm, brownish tone reminiscent of vintage photographs.</li>
        <li><b>High Contrast:</b> Sets each channel to either 0 or 255 depending on whether its value is below or above 128, creating a stark, posterized look.</li>
      </ul>

      <h3>Applications</h3>
      <ul>
        <li>Educational demos for image processing and color theory</li>
        <li>Quick visual experimentation with photos</li>
        <li>Digital art and creative effects</li>
        <li>Learning Canvas API and pixel manipulation</li>
      </ul>

      <h3>Conclusion</h3>
      <p>
        Basic Pixel Coloration shows how easy it is to manipulate image colors in the browser using JavaScript and Canvas. Upload your own photo and try out the effects to see how pixel data can be transformed in real time!
      </p>
    </div>

  <script>
  const canvasOR = document.getElementById('CanvasOR');
  const canvasBW = document.getElementById('CanvasBW');
  const contextOR = canvasOR.getContext('2d');
  const contextBW = canvasBW.getContext('2d');
  const effectSelector = document.getElementById('effectSelector');
  const imageUpload = document.getElementById('imageUpload');
  let imageObj = new Image();

    var RColorRange = [0,1,3,4,6,8,9,11,12,14,16,17,19,20,22,24,25,27,28,30,32,33,35,36,38,40,41,43,44,46,48,49,51,52,54,56,57,59,60,62,64,65,67,68,70,72,73,75,76,78,80,81,83,84,86,88,89,91,92,94,96,97,99,100,102,104,105,107,108,110,112,113,115,116,118,120,121,123,124,126,128,129,131,132,134,136,137,139,140,142,144,145,147,148,150,152,153,155,156,158,160,161,163,164,166,168,169,171,172,174,176,177,179,180,182,184,185,187,188,190,192,193,195,196,198,200,201,203,204,206,208,209,211,212,214,216,217,219,220,222,224,225,227,228,230,232,233,235,236,238,240,241,243,244,246,248,249,251,252,254,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255],
    GColorRange = [0,1,2,4,5,6,8,9,10,12,13,14,16,17,18,20,21,22,24,25,26,28,29,31,32,33,35,36,37,39,40,41,43,44,45,47,48,49,51,52,53,55,56,58,59,60,62,63,64,66,67,68,70,71,72,74,75,76,78,79,80,82,83,84,86,87,89,90,91,93,94,95,97,98,99,101,102,103,105,106,107,109,110,111,113,114,116,117,118,120,121,122,124,125,126,128,129,130,132,133,134,136,137,138,140,141,142,144,145,147,148,149,151,152,153,155,156,157,159,160,161,163,164,165,167,168,169,171,172,174,175,176,178,179,180,182,183,184,186,187,188,190,191,192,194,195,196,198,199,201,202,203,205,206,207,209,210,211,213,214,215,217,218,219,221,222,223,225,226,227,229,230,232,233,234,236,237,238,240,241,242,244,245,246,248,249,250,252,253,254,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255],
    BColorRange = [50,50,51,51,52,52,53,53,54,55,55,56,56,57,57,58,58,59,60,60,61,61,62,62,63,64,64,65,65,66,66,67,67,68,69,69,70,70,71,71,72,72,73,74,74,75,75,76,76,77,78,78,79,79,80,80,81,81,82,83,83,84,84,85,85,86,86,87,88,88,89,89,90,90,91,92,92,93,93,94,94,95,95,96,97,97,98,98,99,99,100,100,101,102,102,103,103,104,104,105,106,106,107,107,108,108,109,109,110,111,111,112,112,113,113,114,114,115,116,116,117,117,118,118,119,120,120,121,121,122,122,123,123,124,125,125,126,126,127,127,128,128,129,130,130,131,131,132,132,133,134,134,135,135,136,136,137,137,138,139,139,140,140,141,141,142,142,143,144,144,145,145,146,146,147,148,148,149,149,150,150,151,151,152,153,153,154,154,155,155,156,156,157,158,158,159,159,160,160,161,162,162,163,163,164,164,165,165,166,167,167,168,168,169,169,170,170,171,172,172,173,173,174,174,175,176,176,177,177,178,178,179,179,180,181,181,182,182,183,183,184,184,185,186,186,187,187,188,188,189,190,190,191,191,192,192];

    const effects = {
      0: { R: RColorRange, G: GColorRange, B: BColorRange },
      1: { R: Array.from({length:256}, (_,i)=>255-i), G: Array.from({length:256}, (_,i)=>255-i), B: Array.from({length:256}, (_,i)=>255-i) },
      2: { R: Array.from({length:256}, (_,i)=>i), G: Array.from({length:256}, (_,i)=>i), B: Array.from({length:256}, (_,i)=>i) },
      3: { R: Array.from({length:256}, (_,i)=>Math.min(255, i*0.393 + i*0.769 + i*0.189)), G: Array.from({length:256}, (_,i)=>Math.min(255, i*0.349 + i*0.686 + i*0.168)), B: Array.from({length:256}, (_,i)=>Math.min(255, i*0.272 + i*0.534 + i*0.131)) },
      4: { R: Array.from({length:256}, (_,i)=>i < 128 ? 0 : 255), G: Array.from({length:256}, (_,i)=>i < 128 ? 0 : 255), B: Array.from({length:256}, (_,i)=>i < 128 ? 0 : 255) }
    };

    function loadImage(src) {
      imageObj = new Image();
      imageObj.crossOrigin = 'anonymous';
      imageObj.onload = function () {
        // Resize canvases to match image size
        canvasOR.width = imageObj.naturalWidth;
        canvasOR.height = imageObj.naturalHeight;
        canvasBW.width = imageObj.naturalWidth;
        canvasBW.height = imageObj.naturalHeight;
        contextOR.clearRect(0, 0, canvasOR.width, canvasOR.height);
        contextBW.clearRect(0, 0, canvasBW.width, canvasBW.height);
        contextOR.drawImage(imageObj, 0, 0, canvasOR.width, canvasOR.height);
        applyEffect();
      };
      imageObj.src = src;
    }

    // Load default image on startup
    loadImage('images/user-image.jpg');

    imageUpload.addEventListener('change', function (e) {
      const file = e.target.files[0];
      if (file) {
        const reader = new FileReader();
        reader.onload = function (evt) {
          loadImage(evt.target.result);
        };
        reader.readAsDataURL(file);
      }
    });

    function applyEffect() {
      // Always show processed image and apply effect
      canvasOR.style.display = 'none';
      canvasBW.style.display = 'block';
      contextBW.drawImage(imageObj, 0, 0, canvasBW.width, canvasBW.height);
      const imgd = contextBW.getImageData(0, 0, canvasBW.width, canvasBW.height);
      const imageData = imgd.data;
      const selected = effects[effectSelector.value];

      for (let c = 0; c < imageData.length; c += 4) {
        if (effectSelector.value === "2") {
          const avg = (imageData[c] + imageData[c+1] + imageData[c+2]) / 3;
          imageData[c] = imageData[c+1] = imageData[c+2] = avg;
        } else {
          imageData[c] = selected.R[imageData[c]];
          imageData[c+1] = selected.G[imageData[c+1]];
          imageData[c+2] = selected.B[imageData[c+2]];
        }
      }

      contextBW.putImageData(imgd, 0, 0);
    }

    function toggleCanvas() {
      const isOriginalVisible = canvasOR.style.display !== 'none';
      canvasOR.style.display = isOriginalVisible ? 'none' : 'block';
      canvasBW.style.display = isOriginalVisible ? 'block' : 'none';
    }
  </script>
</body>
</html>
